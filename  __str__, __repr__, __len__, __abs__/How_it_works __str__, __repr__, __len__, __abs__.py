class Cat:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        """Маг. метод для отображения инфо. об объекте класса в реж отладки
        (для разработчиков). Обратите внимание, этот метод должен возвращать строку,
        поэтому здесь записан оператор return и формируемая строка. Что именно возвращать,
        мы решаем сами, в данном случае – это название класса и имя кошки."""
        return f"{self.__class__}: {self.name}"

    # def __str__(self):
    #     """Магический метод для отображения информации об объекте класса для пользователей (
    #     например, для функций print, str)"""
    #     return f"{self.name}"


cat = Cat('Васька')

print(cat)   # Без  __repr__ мы увидим следующее    <__main__.Cat object at 0x000001E110E63790>
print(cat)   # C __repr__ мы увидим следующее       <class '__main__.Cat'>: Васька

"""
По идее, здесь должен отрабатывать другой магический метод __str__, но так как он у 
нас еще не переопределен, то автоматически выполняется метод __repr__.
Давайте добавим второй магический метод __str__ и посмотрим, как это повлияет на 
отображение данных. Раскомментируйте __str__.
"""
print(cat)   # C __str__ мы увидим следующее       Васька
print('\n\n\n')


class Point:
    def __init__(self, *args):
        self.__coords = args

    def __len__(self):
        """Позволяет применять функцию len() к экземплярам класса"""
        return len(self.__coords)

    def __abs__(self):
        """Позволяет применять функцию abs() к экземплярам класса."""
        return list(map(abs, self.__coords))


p = Point(1, -2)
print(len(p))   # Если запустить программу без переопределенного __len__, то увидим ошибку,
# так как функция len не применима к экземплярам классов по умолчанию.
print(abs(p))   # Если запустить программу без переопределенного __abs__, то увидим ошибку,
# так как функция abs не применима к экземплярам классов по умолчанию.




