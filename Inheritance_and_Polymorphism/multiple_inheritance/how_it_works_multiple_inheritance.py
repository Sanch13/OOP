# В языке Python допускается множественное наследование, когда один дочерний класс образуется
# сразу от нескольких базовых, согласно синтаксису:
# class A(base1, base2, …, baseN):
# идея миксинов (mixins) в Python реализуется через множественное наследование.

class Goods:
    def __init__(self, name, weight, price):
        print("init Goods")
        self.name = name
        self.weight = weight
        self.price = price
        super().__init__()

    def print_info(self):
        print(f"{self.name}, {self.weight}, {self.price}")


# добавить возможность логирования товаров. воспользуемся идеей миксинов.
class MixinLog:
    """Этот класс работает совершенно независимо от классов Goods и Notebook и лишь добавляет
     функционал по логированию товаров с использованием их id. Такие независимые базовые классы
     и получили название миксинов – примесей."""
    ID = 0

    def __init__(self):
        print("init MixinLog")
        MixinLog.ID += 1
        self.id = MixinLog.ID
        super().__init__()

    def save_sell_log(self):
        print(f"{self.id}: товар продан в 00:00 часов")

    def print_info(self):
        print("print_info класса MixinLog")


class MixinLog2:
    def __init__(self):
        print("init MixinLog 2")


class NoteBook(Goods, MixinLog, MixinLog2):
    pass


n = NoteBook("Acer", 1.5, 30000)  # init Goods -> init MixinLog -> init MixinLog 2
n.print_info()  # Acer, 1.5, 30000
n.save_sell_log()  # 1: товар продан в 00:00 часов
# при создании объектов инициализатор ищется сначала в дочернем классе, но так как его там нет,
# то в первом базовом Goods. Он там есть, выполняется и на этом инициализация нашего объекта
# NoteBook завершается. Однако, нам нужно также взывать инициализатор и второго базового класса
# MixinLog. В данном случае, сделать это можно с помощью объекта-посредника super(), которая
# и делегирует вызов метода __init__ класса MixinLog
# В Python существует специальный алгоритм обхода базовых классов при множественном наследовании
# MRO – Method Resolution Order
print(NoteBook.__mro__)
# (<class '__main__.NoteBook'>, <class '__main__.Goods'>, <class '__main__.MixinLog'>, <class 'object'>)
# методы сначала ищутся в самом классе NoteBook, затем, в классе Goods, далее идет класс MixinLog
# и от него уже идет к классу object. Это цепочка обхода для нашего конкретного примера. При
# другой иерархии наследования эта цепочка может быть другой, но одно всегда неизменно –первый
# базовый класс, указанный при наследовании, выбирается первым (после дочернего, разумеется).
# И это важный момент. Вы всегда можете быть уверены, что инициализатор первого базового класса
# сработает в первую очередь. Почему это важно? Смотрите, при создании объекта NoteBook мы
# передаем ему три аргумента. Эти три аргумента, затем, передаются в инициализатор. И так как
# первым будет вызван инициализатор класса Goods, то мы уверены, что эти аргументы будут переданы
# именно в него, а не в какой-то другой инициализатор других базовых классов. И какая бы цепочка
# наследования у нас ни была, все равно первым будет вызываться метод __init__ класса Goods, потому
# что он записан первым. Это гарантирует работоспособность нашей программы при разных иерархиях
# множественного наследования. Так что порядок следования базовых классов при множественном
# наследовании имеет важное значение. Первым должен идти «основной» класс и у него, как
# правило, инициализатор имеет несколько параметров. А далее, записываются классы, у которых,
# опять же, как правило, инициализаторы имеют только параметр self. Это второй важный момент.
# Когда мы собираемся использовать множественное наследование, то структуру классов следует
# продумывать так, чтобы инициализаторы вспомогательных классов имели только один параметр self,
# иначе будут сложности их использования. В каждом методе __init__ мы также делаем делегированный
# вызов инициализатора следующего базового класса. функция super() в классе Goods вызовет
# метод __init__ класса MixinLog , а затем, метод __init__ класса MixinLog2. Чтобы в программах
# при множественном наследовании не возникало проблем с зависимостью последовательности
# наследования дополнительных базовых классов, их инициализаторы следует создавать с одним
# параметром self и в каждом из них прописывать делегированный вызов инициализатора следующего
# класса командой:  super().__init__().
# если мы хотим вызвать этот метод print_info() из второго базового класса MixinLog?
# Сделать это можно двумя способами. Либо напрямую вызвать этот метод через класс MixinLog:
# MixinLog.print_info(n) Обратите внимание, что в этом случае нам обязательно нужно указать
# первым аргументом ссылку на объект класса NoteBook.  Либо, определить какой-либо метод в классе
# NoteBook (пусть он называется также):
# class NoteBook(Goods, MixinLog):
#     def print_info(self):
#         MixinLog.print_info(self)
# Обычно, если нужно делать такие подмены, то есть, из конкретного дочернего класса вызывать метод
# другого (не первого) базового класса, то создают метод в дочернем классе с тем же именем,
# а затем, явно указывают нужный базовый класс.
