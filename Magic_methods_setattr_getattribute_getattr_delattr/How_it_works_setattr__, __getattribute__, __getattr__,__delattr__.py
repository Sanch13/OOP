# class Point:
#     # """Мы видим определение четырех атрибутов: двух свойств MAX_COORD и
#     # MIN_COORD и двух методов __init__ и set_coord. Это атрибуты класса
#     # и при создании экземпляров. Эти атрибуты остаются в пространстве
#     # имен класса, не копируются в экземпляры. Но из экземпляров мы можем
#     # совершенно спокойно к ним обращаться, так как пространство имен объектов
#     # содержит ссылку на внешнее пространство имен класса. Если какой-либо
#     # атрибут не существует в экземпляре, то поиск переходит во внешнее
#     # пространство, то есть, в класс и поиск продолжается там. Поэтому мы
#     # совершенно спокойно можем через экземпляр обратиться к свойству класса
#     # MAX_COORD"""
#
#     MIN_COORD = 0       # атрибут класса. min критерий
#     MAX_COORD = 100     # атрибут класса. max критерий
#
#     def __init__(self, x, y):
#         self.x = x
#         self.y = y
#
#     def set_coord(self, x, y):
#         self.x = x
#         self.y = y
#
#     def set_bound(self, left):
#         """Давайте предположим, что нам нужен метод, который бы изменял значение атрибута класса
#          MIN_COORD. Иногда ошибочно здесь рассуждают так. Мы обращаемся к атрибуту класса
#          MIN_COORD и присваиваем ему новое значение left. Да, когда мы через self (ссылку на
#          объект) записываем имя атрибута и присваиваем ему какое-либо значение, то оператор
#          присваивания создает этот атрибут в локальной области видимости, то есть, в самом объекте.
#          В результате у нас появляется новое локальное свойство в экземпляре класса.
#          А в самом классе одноименный атрибут остается без изменений."""
#         self.MIN_COORD = left
#
#     @classmethod
#     def set_bound_2(cls, left):
#         """Поэтому, правильнее было бы здесь объявить метод уровня класса и через него менять
#          значения атрибутов MIN_COORD и MAX_COORD"""
#         cls.MIN_COORD = left
#
# pt1 = Point(1, 2)
# print('1-->', pt1.MAX_COORD)   # 100. Мы через объект pt1 класса Point обратились
#                                #  к атр. класса MAX_COORD
# pt1.set_bound(-100)            # пытаемся изменить атр. класса MIN_COORD через метод set_bound
# print('2-->', pt1.__dict__)    # {'x': 1, 'y': 2, 'MIN_COORD': -100}. Соз. лок. св-во в объекте pt1
# print('3-->', Point.__dict__)  # {'MIN_COORD': 0}. Атр. класса NIN_COORD остался без изменений
# pt1.set_bound_2(-500)          # пытаемся изменить атр. класса MIN_COORD через метод set_bound_2
# print('4-->', pt1.__dict__)    # {'x': 1, 'y': 2, 'MIN_COORD': -100}. В области объекта pt1
#                                # ничего не изменилось
# print('5-->', Point.__dict__)  # {'MIN_COORD': -500}. Атр. класса NIN_COORD изменился.

##################################################################################################

# __setattr__(self, key, value)__ – автоматически вызывается при изменении свойства key класса;

# __getattribute__(self, item) – автоматически вызывается при получении
# свойства класса с именем item;

# __getattr__(self, item) – автоматически вызывается при получении
# несуществующего свойства item класса;

# __delattr__(self, item) – автоматически вызывается при удалении
# свойства item (не важно: существует оно или нет).

class Point:
    MIN_COORD = 0       # атрибут класса. min критерий
    MAX_COORD = 100     # атрибут класса. max критерий

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __getattribute__(self, item):
        """Он автоматически вызывается, когда идет считывание атрибута через экземпляр класса.
        Метод должен возвращать значение того атрибута которому мы обращаемся. Без return по
        умолчанию возвращает None"""
        # if item == "y":  # Если item == лок. св-ву "y" вывод. исключ. Запрет к обращ. item.
        #     raise ValueError("Доступ к этой переменной запрещен")
        print("__getattribute__", end='  ')   # вывод в консоль. Указ. что метод отработал
        return object.__getattribute__(self, item)  # Вернет знач. item экз. класса
        # так тоже можно super().__getattribute__(item)

    def __setattr__(self, key, value):
        """Метод автоматически вызывается в момент присваивания атрибуту нового значения. В
        момент создания экз. класса в инициализаторе __init__ создавались лок. св-ва x и y.  В
        этот момент вызывался данный метод. Также в переопределенном методе __setattr__ мы
        должны вызывать соответствующий метод из базового класса object, иначе, лок. св-ва в
        экземплярах создаваться не будут."""
        # if key == 'z':  # Если имя атрибута 'z' вывод. исключ. Запрет к созданию с именем 'z'.
        #     raise AttributeError("Недопустимое имя атрибута")
        print("__setattr__", key, value, end=" ")   # вывод в консоль. Указ. что метод отработал
        object.__setattr__(self, key, value)    # вызов базового класса с передачей параметров
        # self.x = value  # будет рекурсия. Так нельзя обращаться
        # self.__dict__[key] = value  # так можно обращаться. В коллекцию экз. класса по ключу
        # [key] мы установим значение value

    def __getattr__(self, item):
        """Метод __getattr__ автоматически вызывается, если идет обращение к несуществующему
        атрибуту. Если нам необходимо определить класс, в котором при обращении к
        несуществующим атрибутам возвращается значение False, а не генерируется исключение,
        нужно в этом методе просто вернуть False (return False)"""
        print("__getattr__: " + item)   # вывод в консоль. Указ. что метод отработал
        # return False    # Если в лок. коллекции экз. класса нет item вернется False

    def __delattr__(self, item):
        """Метод __delattr__ вызывается в момент удаления какого-либо атрибута из экземпляра
        класса"""
        print("__delattr__: " + item)   # вывод в консоль. Указ. что метод отработал
        object.__delattr__(self, item)  # вызов баз. класса с передачей пар-ров для удал. его
        # из коллекции

pt1 = Point(1, 2)   # __setattr__ x 1 __setattr__ y 2. Метод __setattr__ сработает 2 раза
pt1.z = 5   # Создаем лок. св-во в экз. класса с именем 'z'. Сработает исключ. в __setattr__.
print(pt1.z)    # Пытаемся вывести. Сработало исключение в методе __setattr__
print()     # Для удобного отображения в консоли
print(pt1.MAX_COORD)  # Выведет в консоль {__getattribute__  100}. Мы обращаемся через объект
# класса к атрибуту класса. Будет автомат. вызван метод __getattribute__ и вернет знач. item.
print(pt1.x)  # Выведет в консоль {__getattribute__  1}. Мы обращаемся через объект класса
# к лок. св-ву экз. класса. Будет автомат. вызван метод __getattribute__ и вернет знач. item.
print(Point.MIN_COORD)  # Выведет в консоль {0}. Метод __getattribute__ не будет вызван.
print(pt1.y)  # Сгенер. исключ. ValueError. Не сможем обрат. к лок. св-ву "y" экз. класса.
print()     # Для удобного отображения в консоли
print(pt1.yy)   # __getattribute__  __getattr__: yy None. C начала сработает __getattribute__,
# посмотрит что нет такого лок. св-ва и вызовет __getattr__. Метод __getattr__ # отработает
# и вернет None. Если атрибут сущ. отработает метод __getattribute__.
print()     # Для удобного отображения в консоли
del pt1.x   # Удаляем лок. св-во экз. класса pt1. В консоли отобразится __delattr__: x
print(pt1.__dict__)  # Выводим коллецию лок. св-тв экз. класса pt1. Отработает метод
# __getattribute__, далее вывод {'y': 2, 'z': 5}. Лок. св-во pt1.x было удаленно.
##################################################################################################
