# Если объекты a == b (равны), то равен и их хэш.
# Если равны хеши: hash(a) == hash(b), то
#                           объекты могут быть равны (a == b), но могут быть и не равны (a != b).
# Если хеши не равны: hash(a) != hash(b), то объекты точно не равны.

num1 = 256
num2 = 256
print(num1 == num2, f"[a->{id(num1)}]  [b->{id(num2)}]", hash(num1) == hash(num2), hash(num1),
      hash(num2))
# True [a->10927656]  [b->10927656] True 256 256
# Объекты одинаковые, то их hashes так же одинаковые !!!

# a = -1
# b = -2
# d = {}
# print(a == b, f"[a->{id(a)}]  [b->{id(b)}]", hash(a) == hash(b), hash(a), hash(b))
# # False [a->10919432]  [b->10919400] True -2 -2 # Объекты разные, но их hash одинаков !!!
# d[hash(a)] = "Здесь ключом является хэш от объекта а, его значение -1"
# print(d)  # {-2: 'Здесь ключом является хэш от объекта а, его значение -1'}
# d[hash(b)] = "Здесь ключом является хэш от объекта b, его значение -2"
# print(d)  # {-2: 'Здесь ключом является хэш от объекта b, его значение -2'}
# мы переписали значение так как одинаковый хэш хотя объекты a и b разные !!!

# В действительности некоторые объекты в Python, например, словари используют хэши в
# качестве своих ключей. это необходимо, чтобы можно было вычислить хеш объектов и ключи
# хранить в виде: (хэш ключа, ключ)
# Дело в том, что первоначально нужная запись в словаре ищется по хэшу, так как существует
# быстрый алгоритм поиска нужного значения хэша. А, затем, для равных хешей
# (если такие были обнаружены), отбирается запись с указанным в ключе объекте.
# Такой подход значительно ускоряет поиск значения в словаре


class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y

    # Теперь у нас объекты с одинаковыми координатами будут считаться равными. Но при запуске
    # программы возникает ошибка «unhashable type», то есть, наши объекты стали не хэшируемыми.
    # Да, как только происходит переопределение оператора ==, то начальный алгоритм вычисления хэша
    # для таких объектов перестает работать. Поэтому, нам здесь нужно прописать свой способ
    # вычисления хэша объектов через магический метод __hash__()

    def __hash__(self):
        return hash((self.x, self.y))
    # hash для кортежа из координат точки. Этот кортеж относится к неизменяемому типу, поэтому
    # для него можно применить стандартную функцию hash(). То есть, мы подменили вычисление хэша
    # объекта класса Point на вычисление хэша от координат точки. Теперь, после запуска программы
    # видим, что объекты равны и их хэши также равны.


p1 = Point(1, 2)
p2 = Point(1, 2)
print(p1 == p2)
print(hash(p1), hash(p2), sep='\n')
p = (1, 2)
print(hash(p) == hash(p1), id(p) == id(p1))  # True False Хэши одинаковые, но объекты разные
d = {}
d[p1] = 1
d[p2] = 2
print(d)

# При попытке понять и операторы idand необходимо усвоить три концепции : identity , value и hash
# value . Не все объекты имеют все три.hash==is
# 1) У всех объектов есть идентификатор , хотя в некоторых случаях даже он может быть немного
# скользким. Функция idвозвращает число, соответствующее идентификатору объекта (в cpython
# она возвращает адрес объекта в памяти, но другие интерпретаторы могут возвращать что-то еще).
# Если два объекта (которые существуют одновременно) имеют одинаковую идентичность, они на самом
# деле являются двумя ссылками на один и тот же объект. Оператор isсравнивает элементы по
# идентичности, a is bэквивалентен id(a) == id(b). Идентификация может стать немного запутанной,
# когда вы имеете дело с объектами, кэшированными где-то в их реализации. Например,
# объекты для небольших целых чисел и строк в cpython не переделываются каждый раз, когда они
# используются. Вместо этого существующие объекты возвращаются каждый раз, когда они необходимы.
# Вы не должны полагаться на это в своем коде, потому что это деталь реализации cpython
# (другие интерпретаторы могут делать это по-другому или вообще не делать).#
# 2) Все объекты также имеют значение , хотя это немного сложнее. Некоторые объекты не имеют
# значимого значения, кроме их идентификатора (поэтому в некоторых случаях значение
# идентификатора может быть синонимом). Значение можно определить как то, что ==сравнивает
# оператор, поэтому в любое время a == bвы можете сказать это aи bполучить то же значение.
# Объекты-контейнеры (например, списки) имеют значение, определяемое их содержимым, в то время
# как некоторые другие типы объектов будут иметь значения, основанные на их атрибутах. Объекты
# разных типов иногда могут иметь одинаковые значения, как и числа:
# 0 == 0.0 == 0j == decimal.Decimal("0") == fractions.Fraction(0) == False
# (да, bools — это числа в Python по историческим причинам).
# Если класс не определяет __eq__метод (для реализации ==оператора), он унаследует версию по
# умолчанию, objectи его экземпляры будут сравниваться исключительно по их идентификаторам.
# Это уместно, когда в остальном идентичные экземпляры могут иметь важные семантические различия.
# Например, два разных сокета, подключенных к одному и тому же порту одного и того же хоста,
# должны обрабатываться по-разному, если один получает веб-страницу HTML, а другой получает
# изображение, связанное с этой страницей, поэтому они не имеют одинакового значения.
# 3) В дополнение к значению некоторые объекты имеют хэш-значение , что означает, что они могут
# использоваться в качестве ключей словаря (и храниться в sets). Функция hash(a)возвращает
# aхеш-значение объекта, число, основанное на значении объекта. Хэш объекта должен оставаться
# неизменным в течение всего времени жизни объекта, поэтому хеширование объекта имеет смысл
# только в том случае, если его значение неизменно (либо потому, что оно основано на
# идентификаторе объекта, либо потому, что оно основано на содержимом объекта). объекты,
# которые сами по себе неизменны).
# # Несколько разных объектов могут иметь одно и то же значение хеш-функции, хотя хорошо
# разработанные хеш-функции позволяют избежать этого, насколько это возможно. Хранение объектов
# с одним и тем же хешем в словаре гораздо менее эффективно, чем хранение объектов с разными
# хэшами (каждое столкновение хэшей требует больше работы). Объекты хешируются по умолчанию
# (поскольку их значением по умолчанию является их идентификатор, который неизменяем). Если вы
# напишите __eq__метод в пользовательском классе, Python отключит эту реализацию хэша по умолчанию,
# поскольку ваша __eq__функция будет определять новое значение значения для своих экземпляров.
# __hash__Вам также нужно будет написать метод, если вы хотите, чтобы ваш класс по-прежнему был
# хэшируемым. Если вы наследуете от хэшируемого класса, но не хотите, чтобы его хешировали сами,
# вы можете установить его __hash__ = None в теле класса.

# Неравные объекты могут иметь одинаковые хеш-значения.
# Да, это правда. Простой пример hash(-1) == hash(-2)в CPython.
