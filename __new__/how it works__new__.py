class Point:
    def __new__(cls, *args, **kwargs):  # __new__ Вызывается непосредственно перед созданием объекта класса
        # магический метод __new__ должен возвращать адрес нового созданного объекта. этот метод всегда вызывается при
        # создании нового объекта. При необходимости, мы можем его переопределять, добавляя новую логику его работы.
        # И то же самое относится ко всем магическим методам. Они всегда существуют у всех классов. Но переопределяем
        # мы лишь те, что необходимо, а остальные работают по умолчанию. В этом сила базового класса object. В нем уже
        # существует программный код, общий для всех классов языка Python. Иначе, нам пришлось бы его каждый раз прописывать заново.
        print('вызов __new__ для ' + str(cls))  # вывод сообщения и переменной cls
        return super().__new__(cls) # функция super() возвращает ссылку на базовый класс и через нее мы вызываем
                                    # метод __new__ с одним первым аргументом.

    def __init__(self, x=0, y=0):   #  метод __init__ вызывается после создания объекта
        print('вызов __init__ для ' + str(self))
        self.x = x
        self.y = y

# pt = Point(1, 2)
# print(pt)
################################################################################################################
class DataBase: # Пример паттерна Singleton
    __instance = None

    def __new__(cls, *args, **kwargs):
        if cls.__instance is None:
            cls.__instance = super().__new__(cls)

        return cls.__instance

    def __del__(self):
        DataBase.__instance = None

    def __init__(self, user, psw, port):
        self.user = user
        self.psw = psw
        self.port = port

    def connect(self):
        print(f'соединение с БД: {self.user}, {self.psw}, {self.port}')

    def close(self):
        print('закрытие соединения с БД')

    def read(self):
        return 'данные из БД'

    def write(self,data):
        print(f'запись в БД {data}')


# db = DataBase('root', '1234', 80)
# db2 = DataBase('root2', '5678', 40)
# print(id(db), id(db2))
# db.connect()
# db2.connect()
################################################################################################################
class AbstractClass:
    def __new__(cls, *args, **kwargs):
        return f'Ошибка: нельзя создавать объекты абстрактного класса'
################################################################################################################
class SingletonFive:
    __count = 0    # атрибут класса. счетчик инициализируем 0
    __link = None  # атрибут класса. Будем использовать для ссылки на объект

    def __new__(cls, *args, **kwargs):
        if cls.__count < 5:     # если атриб. класса cls.__count < 5 то True
            cls.__link = super().__new__(cls)   # создаем объект и атриб. класса cls.__link ссылается на созданный
            cls.__count += 1    # объект. Увеличиваем атр. класса cls.__count на +1. Когда cls.__count == 5
                                # то условие If больше не выполняется и cls.__count будет всегда равен 5. А арт.
                                # класса cls.__link будет ссылаться на пятый созданный объект класса
        return cls.__link       # Возврат атр. класса который ссылается на созданный объект

    def __init__(self, name):   # инициализируем объект класса
        self.name = name        # в каждом объекте класса SingletonFive будет свое лок. св-во self.name


objs = [SingletonFive(str(n)) for n in range(10)]  # эту строчку не менять
for k, v in enumerate(objs):
    print(f'{v} --> {k + 1}', v.__dict__)

