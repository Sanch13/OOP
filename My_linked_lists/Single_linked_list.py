from My_linked_lists.Node import Node  # импортируем класс Node


class LinkedList:
    def __init__(self):  # инициальзатор объектов класса LinkedList
        self.head = None

    def add_data(self, data):   # Добавление объекта (объект Node) в связанный список обьекта класса LinkedList
        """
        Метод add_data(self, data) добавляет объекты Node в связанный список LinkedList.
        В начале создается первый объект Node и ссылка на него присваивается new_node. Далее создается переменная
        cur_node - это текущий указатель позиции связанного списка. По началу он ссылается на лок. св-во
        self.head = None. Мы начинаем добавление объектов. Нам нужно добавить первый объект. Для этого проверяем
        наш cur_node (текущий указатель). Если cur_node==None то нет первого объекта связн. списка.
        Так как мы создали новый объект new_node, мы лок. св-ву self.head (ТЕПЕРЬ ЭТО ВСЕГДА УКАЗАТЕЛЬ НА ПЕРВЫЙ ОБЪЕКТ
        свсязанного списка, согласно теории) переопределим ссылку с None на первый объект Node (self.head = new_node).
        Так как мы добавили объект (просто он первый) нужно выйти из метода add_data(self, data). Просто return и метод
        вернет return = None. На этом метод завершится !!!

        Добавление второго объекта в связаный список.
        Переменная new_node ссылается на второй созданный объект Node. cur_node ссылается на self.head, а мы
        знаем, что self.head уже ПОСТОЯННО ссылается на первый объект Node связ. списка, а не на None. Далее проверка
        if cur_node is None. Так как cur_node ссылается на первый объект Node и не явл. None то условие не истинно. Блок
        if не выполняется. Переходим далее по методу к конструкции while. В while мы обращаемася к текущему объекту
        cur_node (пока мы находимся на первом объекте) и обращаемся к его методу get_next(), который возвращает ссылку
        на следующий объект Node связанного списка. Так как у нас один единственный объект в связанном списке, то его
        лок. св-во next_obj (ссылка на следующий объект) указывает на None. Значит текущий объект cur_node вернет None.
        Соответственно конструкция while не выполнится так, как False. Далее к текущему объекту cur_node первяжем,
        через set_next() (лок. св-ву self.next_obj = obj), ссылку на новый (второй объект Node). В set_next()
        передадим новый (set_next(второй объект new_node класса Node)). Лок. св-ву первого объкта Node присвоится
        ссылка на новый (второй объект Node) self.next_obj = new_node. И локальное св-во первого объкта self.next_obj
        будет ссылаться на второй объект Node. На этом метод завершится !!!

        Добавление последующих элементов.
        Переменная new_node ссылается на третий созданный объект Node. cur_node ссылается на self.head, а мы
        знаем, что self.head уже ПОСТОЯННО ссылается на первый объект Node связ. списка, а не на None. Далее проверка
        if cur_node is None. Так как cur_node ссылается на первый объект Node и не явл. None то условие не истинно. Блок
        if не выполняется. Переходим далее по методу к конструкции while. В while мы обращаемася к текущему объекту
        cur_node (мы находимся на первом объекте) и обращаемся к его методу get_next(), который возвращает ссылку
        на следующий объект Node связанного списка. Так как у первого объекта лок. св-во self.next_obj ссылается
        на второй объект Node и венрнет ссылку то конструкция while истина. cur_node = cur_node.get_next() - констр.
        фактически двигает текущий указатель cur_node по связ. списку. Мы обратимся к лок. св-ву текущ. указателя
        self.next_obj, а он будет указвать на второй объект класа Node. Текущий указатель cur_node будет теперь
        ссылаться на второй объкет класса Node. Снова заходим в конструкцию while. Тут проверяем лок. св-во
        self.next_obj текущего (уже второго объекта) куда оно ссылается, а оно ссылается на None. Соотвественно, оно
        вернет None и конструкция while не истина (False). Далее переходим к cur_node.set_next(new_node) -
        текущ. указателю cur_node и его лок. св-ву self.next_obj присваеваем ссылку на новый объект (третий объект)
        new_node класса Node. На этом метод завершится !!!

        Добавление последующих элементов идентично третьему абзацу.
        """

        new_node = Node(data)   # Переменная new_node ссылается на новый созданный объект класса Node
        cur_node = self.head    # Переменная cur_node ссылается на лок. св-во self.head класса LinkedList
        if cur_node is None:    # Если переменная cur_node==None то нет первого объекта связн. списка и
            self.head = new_node    # лок. св-во self.head будет ссылаться на первый созданный объект Node
            return              # Конструкция с if cur_node is None: отработает всего лишь один раз, когда в
                                # связанном списке нет объектов Node, а далее self.head будет ссылается
                                # на первый объект Node связанного списка LinkedList
        while cur_node.get_next():
            cur_node = cur_node.get_next()
        cur_node.set_next(new_node)  # присваиваем лок. св-ву cur_node self.next_obj ссылку на следующий объект new_node
                                     # self.next_obj = new_node

    def show_data(self):    # Вывод всех данных связанного списка
        """Печатет все данные связанного списка """
        cur_node = self.head    # Так как у нас уже создан связанный список то лок. св-во self.head  ВСЕГДА ссылается
                            # на первый объект связ. списка. Если связ. список пуст то self.head = None и
                            # метод show_data(self) ничего не выведет. Текущ. указат. cur_node указыв. на первый объект
        out_data = []       # создаем список out_data для добавления туда объектов связ. списка.
        while cur_node:     # Проверяем текущ. объект связ. списка. Если != None то добавляем данные в список out_data
            out_data.append(cur_node.get_data())    # добавляем данные текущ. объкта в out_data через метод get_data()
            cur_node = cur_node.get_next()  # Переопределяем ссылку с текущего обекта на следующий объект связ. списка

        print(out_data)  # вывод данных связ. списка в списке out_data

    def len_linked_list(self):  # метод выводит кол-во объектов связ. списка
        """Возвращает длину связанного списка"""
        cur_node = self.head    # текущ. указатель cur_node. Указывает на первый объект связ. списка
        count = 0               # счетчик. инициализируем 0
        while cur_node:         # Проверяем текущ. объект связ. списка. Если != None то увеличиваем счетчик count на 1
            count += 1          # увеличиваем счетчик count на 1
            cur_node = cur_node.get_next() # Переопределяем ссылку с текущего обекта на следующий объект связ. списка

        return count  # возвращает кол-во объектов связ. списка

    def add_front_obj(self, data):  # метод добавляет объект в начало связ. списка
        """Добавляет объект в начало связанного списка"""
        new_node = Node(data)       # Переменная new_node ссылается на новый созданный объект класса Node
        cur_node = self.head        # текущ. указатель cur_node. Указывает на первый объект связ. списка
        new_node.set_next(cur_node)  # У нового объекта лок. св-ву self.next_obj присваивают ссылку на первый (текущий)
                                    # объект связ. списка. Новый объект ссылается на бывший первый объект связ. списка
        self.head = new_node        # Лок. св-ву self.head класса LinkedList присв. ссылку на новый объект new_node.
                                    # Теперь лок. св-ва self.head указывавет на новый (первый) объект св. списка, а
                                    # бывший первый стал вторым.

    def del_last_obj_linked_list(self): # удаление последнего объекта связ. списка
        """Удаляет последний объект связанного списка"""
        cur_node = self.head            # текущ. указатель cur_node. Указывает на первый объект связ. списка
        while cur_node.get_next().get_next():   # смотрим на что указывает (указатель self.next_obj) следующего объекта
            cur_node = cur_node.get_next()      # если на другой объект то истина и мы переходим текущим указателем
                                                # на следующий объект связ. списка. Если None то мы текущ. указателю
                                                # устанавливаем знач. None. Соответственно на последний объект связ.
                                                # спика нет ни одной ссылки. Он удалится сборщиком мусора.
        cur_node.set_next(None)  # Мы предпоследнему объекту связ. списка лок. св-ву self.next_obj указал. ссылку на None

    def del_front_obj_linked_list(self):
        """Удаляет первый объект связанного списка"""
        cur_node = self.head            # текущ. указатель cur_node. Указывает на первый объект связ. списка
        self.head = cur_node.get_next()  # текущ. указатель головы перевязываем  ссылку на второй объект св. списка
                                         # он же и станет указаетлем на первый объект св. списка. так как на предыдущ.
                                        # объект нет ни одной ссылки и он удалится сборщиокм мусора

    def get_data_for_indx(self, indx):
        """Возвращает данные объекта связанного списка по указанному индексу"""
        cur_node = self.head            # текущ. указатель cur_node. Указывает на первый объект связ. списка
        count = 0                       # счетчик. инициализируем 0
        while cur_node.get_next():      # смотрим на что ссылается текущ. объкет. Исли None то выводим данные текущ. obj
            if count == indx:           # если ссылка на obj то проверяем равен ли запрашеваемый индекс count
                return cur_node.get_data()  # если истина то возвращаем данные текущ. объекта
            count += 1                  # добавляем 1 к count
            cur_node = cur_node.get_next()  # Переопределяем ссылку с текущего обекта на следующий объект связ. списка
                                            # Двигаемся указателем по связ. списку
        return f'Index is out of range' if indx > count else cur_node.get_data()    # если заданный индекс больше чем
                                        # кол-во obj в связ. списке то выводим текст f'Index is out of range'
                # первый и последний obj связ. списка будет возвращать строка else cur_node.get_data()

