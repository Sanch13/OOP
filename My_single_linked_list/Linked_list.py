from My_single_linked_list.Node import Node  # импортируем класс Node


class LinkedList:
    def __init__(self):  # инициальзатор объектов класса LinkedList
        self.head = None

    def add_data(self, data):   # Добавление объекта (объект Node) в связанный список обьекта класса LinkedList
        """
        Метод add_data(self, data) добавляет объекты Node в связанный список LinkedList.
        В начале создается первый объект Node и ссылка на него присваивается new_node. Далее создается переменная
        cur_node - это текущий указатель позиции связанного списка. По началу он ссылается на лок. св-во
        self.head = None. Мы начинаем добавление объектов. Нам нужно добавить первый объект. Для этого проверяем
        наш cur_node (текущий указатель). Если cur_node==None то нет первого объекта связн. списка.
        Так как мы создали новый объект new_node, мы лок. св-ву self.head (это всегда указатель на первый объект
        свсязанного списка, согласно теории) переопределим ссылку с None на первый объект Node (self.head = new_node).
        Так как мы добавили объект (просто он первый) нужно выйти из метода add_data(self, data). Просто return и метод
        вернет return = None. На этом метод завершится !!!

        Добавление второго объекта в связаный список.
        Переменная new_node ссылается на второй созданный объект Node. cur_node ссылается на self.head, а мы
        знаем, что self.head уже ссылается на первый объект Node связанного списка, а не на None. Далее проверка
        if cur_node is None. Так как cur_node ссылается на первый объект Node и не явл. None то условие не истинно. Блок
        if не выполняется. Переходим далее по методу к конструкции while. В while мы обращаемася к текущему объекту
        cur_node (пока мы находимся на первом объекте) и обращаемся к его методу get_next(), который возвращает ссылку
        на следующий объект Node связанного списка. Так как у нас один единственный объект в связанном списке, то его
        лок. св-во next_obj (ссылка на следующий объект) указывает на None. Значит текущий объект cur_node вернет None.
        Соответственно конструкция while не выполнится так, как False. Далее к текущему объекту cur_node установим,
        через set_next() (лок. св-ву self.next_obj = obj), ссылку на новый (второй объект Node). В set_next()
        передадим новый (set_next(второй объект new_node класса Node)). Лок. св-ву первого объкта Node присвоится
        ссылка на новый (второй объект Node) self.next_obj = new_node. И локальное св-во первого объкта self.next_obj
        будет ссылаться на второй объект Node. На этом метод завершится !!!

        Добавление последующих элементов.

        :param data:
        :return:
        """

        new_node = Node(data)   # Переменная new_node ссылается на созданный объект класса Node
        cur_node = self.head    # Переменная cur_node ссылается на лок. св-во self.head класса LinkedList
        if cur_node is None:    # Если переменная cur_node==None то нет первого объекта связн. списка и
            self.head = new_node    # лок. св-во self.head будет ссылаться на первый созданный объект Node
            return              # Конструкция с if cur_node is None: отработает всего лишь один раз, когда в
                                # связанном списке нет объектов Node, а далее self.head будет ссылается
                                # на первый объект Node связанного списка LinkedList
        while cur_node.get_next():
            cur_node = cur_node.get_next()
        cur_node.set_next(new_node)  # присваиваем лок. св-ву cur_node self.next_obj ссылку на следующий объект new_node
                                     # self.next_obj = new_node
