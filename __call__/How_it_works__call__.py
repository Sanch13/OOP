import math
"""Функтор (функциональный объект) — объект, который можно использовать как функцию."""

class Counter:
    """Классы, экземпляры которых можно вызывать подобно функциям, получили название функторы"""
    def __init__(self):
        self.counter = 0

    def __call__(self, step=1, *args, **kwargs):    # В явном виде первый параметр step
        print('__call__')       # Выводим сообщение, что был вызван данный метод
        self.counter += step    # Увеличиваем счетчик counter для текущего объекта на step
        return self.counter     # Возвращаем счетчик counter для текущего объекта


"""c = Counter(). Круглые скобки после имени класса. В общем случае – это оператор вызова,
например, так можно вызывать функции. Так можно вызывать и классы. В действительности,
когда происходит вызов класса, то автоматически запускается магический метод __call__ и
в данном случае он создает новый экземпляр этого класса. То есть, класс можно вызывать подобно
функции благодаря встроенной для него реализации магического метода __call__. А вот экземпляры
классов так вызывать уже нельзя. Если записать команду: c(), то возникнет ошибка: «TypeError:
'Counter' object is not callable». Мы можем поправить этот момент, если явно в классе Counter
пропишем магический метод __call__. Смотрите код выше."""

# obj_1 = Counter() При создании объекта obj_1 класса Counter вызываются следующие методы
# 1 вызов   __call__(self, *args, **kwargs):
# 2 вызов       obj = self.__new__(self, *args, **kwargs)
# 3 вызов       self.__init__(obj, *args, **kwargs)
#               return obj


c = Counter()
c2 = Counter()
c()      # - Функторы - вызов экземпляра класса с модифицированным __call__
c(2)     # - Функторы - вызов экземпляра класса с модифицированным __call__
res = c(10)
res2 = c2(-5)
print(res, res2)    # 13 -5


class StripChars:
    """Первый пример - использование класса с методом __call__ вместо замыканий функций."""
    def __init__(self, chars):
        self.__chars = chars    #  __chars – удаляемые символы

    def __call__(self, *args, **kwargs):
        if not isinstance(args[0], str):
            raise ValueError("Аргумент должен быть строкой")
        """Удаляем символы через строковый метод strip для символов __chars."""
        return args[0].strip(self.__chars)


s1 = StripChars("?:!.; ")    # Создаем экз. класса и укажем те символы, которые следует убирать
res = s1(" Hello World! ")   # Вызвать объект s1 подобно функции
print(res)                   # Hello World
"""В результате объект s1 будет отвечать за удаление указанных символов в начале и конце строки.
Но нам ничто не мешает определять другие объекты этого класса с другим набором символов:"""
s1 = StripChars("?:!.; ")    # объект s1 отвечает за удаление ("?:!.; ")
s2 = StripChars(" ")         # объект s2 уже отвечает только за удаление пробелов
res = s1(" Hello World! ")   # Hello World
res2 = s2(" Hello World! ")  # Hello World!
print(res, res2, sep='\n')   # Hello World, Hello World!


class Derivate:
    """Второй пример – это реализация декораторов с помощью классов."""
    def __init__(self, func):
        self.__fn = func     # Здесь в иниц. сохр. ссылку на функцию, которую декорируем

    def __call__(self, x, dx=0.0001, *args, **kwargs):
        """В методе __call__ принимаем один обязательный параметр x – точку, где вычисляется
        производная и dx – шаг изменения при вычислении производной."""
        return (self.__fn(x + dx) - self.__fn(x)) / dx


def df_sin(x):
    return math.sin(x)


print(df_sin(math.pi/3))    # 0.866 вызов ее пока без декорирования

df_sin = Derivate(df_sin)   # пропишем все в явном виде. Теперь df_sin – это экземпляр класса
# Derivate, а не исходная функция. Поэтому, когда она будет вызываться, то запустится
# метод __call__ и вычислится значение производной в точке math.pi/3.
print(df_sin(math.pi/3))    # 0.4999 вызов ее через декоратор класса
# Второй способ – это воспользоваться оператором @ перед объявлением функции @Derivate. Получим
# абсолютно тот же самый результат. Вот принцип создания декораторов функций на основе классов.
# Как видите, все достаточно просто – запоминаем ссылку на функцию, а затем, расширяем
# ее функционал в магическом методе __call__.



