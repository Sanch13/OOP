"""
Используя замыкания функций, определите вложенную функцию, которая бы увеличивала значение
переданного параметра на 5 и возвращала бы вычисленный результат.
При этом внешняя функция должна иметь следующую сигнатуру:
def counter_add(): ...
Вызовите функцию counter_add и результат ее работы присвойте переменной с именем cnt.
 Вызовите внутреннюю функцию через переменную cnt со значением k, введенным с клавиатуры:
k = int(input())
Выведите результат на экран.
Sample Input:
7
Sample Output:
12
"""
# k = int(input())
#
#
# def counter_add():
#     def wrapper(step):
#         return step + 5
#
#     return wrapper
#
#
# cnt = counter_add()
# print(cnt(k))
###################################################################################################
"""
Используя замыкания функций, объявите внутреннюю функцию, которая увеличивает значение 
своего аргумента на некоторую величину n - параметр внешней функции с сигнатурой:
def counter_add(n): ...
Вызовите внешнюю функцию counter_add со значением аргумента 2 и результат присвойте 
переменной cnt. Вызовите внутреннюю функцию через переменную cnt со значением k,
введенным с клавиатуры:
k = int(input())
Выведите результат на экран.
Sample Input:
5
Sample Output:
7
"""
# k = int(input())
#
#
# def counter_add(n):
#     def wrapper(step):
#         nonlocal n
#         return step + n
#
#     return wrapper
#
#
# cnt = counter_add(2)
# print(cnt(k))
###################################################################################################
"""
Используя замыкания функций, объявите внутреннюю функцию, которая заключает в тег h1 строку s 
(s - строка, параметр внутренней функции). Далее, на вход программы поступает строка и ее 
нужно поместить в тег h1 с помощью реализованного замыкания. Результат выведите на экран.
P. S. Пример добавления тега h1 к строке "Python": <h1>Python</h1>
Sample Input:
Balakirev
Sample Output:
<h1>Balakirev</h1>
"""
# s = input()
#
#
# def add_string(s):
#     def tag_h1():
#         nonlocal s
#         return f'<h1>{s}</h1>'
#
#     return tag_h1
#
#
# h1 = add_string(s)
# print(h1())
###################################################################################################
"""
Используя замыкания функций, объявите внутреннюю функцию, которая заключает строку s 
(s - строка, параметр внутренней функции) в произвольный тег, содержащийся в переменной 
tag - параметре внешней функции. 
Далее, на вход программы поступают две строки: первая с тегом, вторая с некоторым 
содержимым. Вторую строку нужно поместить в тег из первой строки с помощью реализованного 
замыкания. Результат выведите на экран.
P. S. Пример добавления тега h1 к строке "Python": <h1>Python</h1>
Sample Input:
div
Сергей Балакирев
Sample Output:
<div>Сергей Балакирев</div>
"""
# tag = input()
# name = input()
#
#
# def add_tag(tag):
#     def add_string(string):
#         nonlocal tag
#         return f'<{tag}>{string}</{tag}>'
#
#     return add_string
#
#
# tag = add_tag(tag)
# print(tag(name))
###################################################################################################
"""
Используя замыкания функций, объявите внутреннюю функцию, которая преобразует строку из 
списка целых чисел, записанных через пробел, либо в список, либо в кортеж. Тип коллекции 
определяется параметром tp внешней функции. Если tp = 'list', то используется список, иначе 
(при другом значении) - кортеж.
Далее, на вход программы поступают две строки: первая - это значение для параметра tp; 
вторая - список целых чисел, записанных через пробел. С помощью реализованного замыкания 
преобразовать эти данные в соответствующую коллекцию. Результат вывести на экран командой 
(lst - ссылка на коллекцию):
print(lst)
Sample Input:
list
-5 6 8 11 0 111 -456 3
Sample Output:
[-5, 6, 8, 11, 0, 111, -456, 3]
"""
# tp = input()
# sequence_num = map(int, input().split())
#
#
# def add_type(tp):
#     def print_sequence(sequence):
#         nonlocal tp
#         return tuple(sequence) if tp != 'list' else list(sequence)
#
#     return print_sequence
#
#
# lst = add_type(tp)(sequence_num)
# print(lst)
###################################################################################################
"\nDECORATES  DECORATES  DECORATES   DECORATES  DECORATES  DECORATES   DECORATES\n"

###################################################################################################
"""
Объявите функцию с именем get_sq, которая вычисляет площадь прямоугольника по двум параметрам:
 width и height - ширина и высота прямоугольника. И возвращает результат (сама ничего на 
 экран не выводит). То есть, функция имеет сигнатуру:
def get_sq(width, height): ...
Определите декоратор func_show для этой функции, который ОТОБРАЖАЕТ результат на экране в 
виде строки (без кавычек):
"Площадь прямоугольника: <значение>"
Вызывать функцию и декоратор не нужно, только объявить. ПРИМЕНЯТЬ декоратор к функции также 
не нужно.
Sample Input:
8 11
Sample Output:
Площадь прямоугольника: 88
"""
# def func_show(func, *args, **kwargs):
#     def wrapper(*args, **kwargs):
#         print(f'Площадь прямоугольника: {func(*args)}')
#
#     return wrapper
#
#
# def get_sq(width, height):
#     return width * height
#
# x, y = map(int, input().split())
# get_sq = func_show(get_sq)(x, y)
###################################################################################################





